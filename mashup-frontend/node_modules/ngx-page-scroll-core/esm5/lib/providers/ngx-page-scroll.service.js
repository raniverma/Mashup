/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, isDevMode } from '@angular/core';
import { PageScrollInstance } from '../page-scroll-instance';
import { defaultPageScrollConfig, NGXPS_CONFIG } from './config.provider';
import * as i0 from "@angular/core";
import * as i1 from "./config.provider";
var PageScrollService = /** @class */ (function () {
    function PageScrollService(customConfig) {
        var _this = this;
        this.runningInstances = [];
        this.onInterrupted = {
            report: (/**
             * @param {?} event
             * @param {?} pageScrollInstance
             * @return {?}
             */
            function (event, pageScrollInstance) {
                if (!pageScrollInstance.pageScrollOptions.interruptible) {
                    // Non-interruptible anyway, so do not stop anything
                    return;
                }
                /** @type {?} */
                var shouldStop = true;
                if (event.type === 'keyup') {
                    // Only stop if specific keys have been pressed, for all others don't stop anything
                    if (_this.config.interruptKeys.indexOf(((/** @type {?} */ (event))).key) === -1) {
                        // The pressed key is not in the list of interrupting keys
                        shouldStop = false;
                    }
                }
                else if (event.type === 'mousedown') {
                    // For mousedown events we only stop the scroll animation of the mouse has
                    // been clicked inside the scrolling container
                    if (!pageScrollInstance.pageScrollOptions.scrollViews.some((/**
                     * @param {?} scrollingView
                     * @return {?}
                     */
                    function (scrollingView) { return scrollingView.contains((/** @type {?} */ (event.target))); }))) {
                        // Mouse clicked an element which is not inside any of the the scrolling containers
                        shouldStop = false;
                    }
                }
                if (shouldStop) {
                    _this.stopAll(pageScrollInstance.pageScrollOptions.namespace);
                }
            }),
        };
        this.config = tslib_1.__assign({}, defaultPageScrollConfig, customConfig);
        if (PageScrollService.instanceCounter > 0 &&
            (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode()))) {
            console.warn('An instance of PageScrollService already exists, usually ' +
                'including one provider should be enough, so double check.');
        }
        PageScrollService.instanceCounter++;
    }
    /**
     * @private
     * @param {?} interrupted
     * @param {?} pageScrollInstance
     * @return {?}
     */
    PageScrollService.prototype.stopInternal = /**
     * @private
     * @param {?} interrupted
     * @param {?} pageScrollInstance
     * @return {?}
     */
    function (interrupted, pageScrollInstance) {
        /** @type {?} */
        var index = this.runningInstances.indexOf(pageScrollInstance);
        if (index >= 0) {
            this.runningInstances.splice(index, 1);
        }
        if (pageScrollInstance.interruptListenersAttached) {
            pageScrollInstance.detachInterruptListeners();
        }
        if (pageScrollInstance.timer) {
            // Clear/Stop the timer
            clearInterval(pageScrollInstance.timer);
            // Clear the reference to this timer
            pageScrollInstance.timer = undefined;
            pageScrollInstance.fireEvent(!interrupted);
            return true;
        }
        return false;
    };
    /**
     * @param {?} options
     * @return {?}
     */
    PageScrollService.prototype.create = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return new PageScrollInstance((/** @type {?} */ (tslib_1.__assign({}, this.config, options))));
    };
    /**
     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.
     *
     * This is the core functionality of the whole library.
     */
    // tslint:disable-next-line:cyclomatic-complexity
    /**
     * Start a scroll animation. All properties of the animation are stored in the given {\@link PageScrollInstance} object.
     *
     * This is the core functionality of the whole library.
     * @param {?} pageScrollInstance
     * @return {?}
     */
    // tslint:disable-next-line:cyclomatic-complexity
    PageScrollService.prototype.start = /**
     * Start a scroll animation. All properties of the animation are stored in the given {\@link PageScrollInstance} object.
     *
     * This is the core functionality of the whole library.
     * @param {?} pageScrollInstance
     * @return {?}
     */
    // tslint:disable-next-line:cyclomatic-complexity
    function (pageScrollInstance) {
        var _this = this;
        // Merge the default options in the pageScrollInstance options
        pageScrollInstance.pageScrollOptions = (/** @type {?} */ (tslib_1.__assign({}, this.config, pageScrollInstance.pageScrollOptions)));
        // Stop all possibly running scroll animations in the same namespace
        this.stopAll(pageScrollInstance.pageScrollOptions.namespace);
        if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {
            // No scrollViews specified, thus we can't animate anything
            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {
                console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');
            }
            return;
        }
        /** @type {?} */
        var startScrollPositionFound = false;
        // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next
        pageScrollInstance.startScrollPosition = 0;
        // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)
        pageScrollInstance.pageScrollOptions.scrollViews.forEach((/**
         * @param {?} scrollingView
         * @return {?}
         */
        function (scrollingView) {
            if (scrollingView === undefined || scrollingView === null) {
                return;
            }
            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its "scrollTop"
            // or "scrollLeft" property that is not undefined and unequal to 0
            /** @type {?} */
            var scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);
            if (!startScrollPositionFound && scrollPosition) {
                // We found a scrollingView that does not have scrollTop or scrollLeft 0
                // Return the scroll position value, as this will be our startScrollPosition
                pageScrollInstance.startScrollPosition = scrollPosition;
                startScrollPositionFound = true;
            }
        }));
        /** @type {?} */
        var pageScrollOffset = pageScrollInstance.getCurrentOffset();
        // Calculate the target position that the scroll animation should go to
        /** @type {?} */
        var scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();
        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);
        // Calculate the distance we need to go in total
        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;
        if (isNaN(pageScrollInstance.distanceToScroll)) {
            // We weren't able to find the target position, maybe the element does not exist?
            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {
                console.log('Scrolling not possible, as we can\'t find the specified target');
            }
            pageScrollInstance.fireEvent(false);
            return;
        }
        // We're at the final destination already
        // OR we need to scroll down but are already at the end
        // OR we need to scroll up but are at the top already
        /** @type {?} */
        var allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance;
        // Check how long we need to scroll if a speed option is given
        // Default executionDuration is the specified duration
        pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration;
        // Maybe we need to pay attention to the speed option?
        if ((pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null) &&
            (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {
            // Speed option is set and no duration => calculate duration based on speed and scroll distance
            pageScrollInstance.executionDuration =
                Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;
        }
        // We should go there directly, as our "animation" would have one big step
        // only anyway and this way we save the interval stuff
        /** @type {?} */
        var tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;
        if (allReadyAtDestination || tooShortInterval) {
            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {
                if (allReadyAtDestination) {
                    console.log('Scrolling not possible, as we can\'t get any closer to the destination');
                }
                else {
                    console.log('Scroll duration shorter that interval length, jumping to target');
                }
            }
            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);
            pageScrollInstance.fireEvent(true);
            return;
        }
        // Register the interrupt listeners if we want an interruptible scroll animation
        if (pageScrollInstance.pageScrollOptions.interruptible) {
            pageScrollInstance.attachInterruptListeners(this.onInterrupted);
        }
        // Let's get started, get the start time...
        pageScrollInstance.startTime = new Date().getTime();
        // .. and calculate the end time (when we need to finish at last)
        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;
        pageScrollInstance.timer = setInterval((/**
         * @param {?} _pageScrollInstance
         * @return {?}
         */
        function (_pageScrollInstance) {
            // Take the current time
            /** @type {?} */
            var currentTime = new Date().getTime();
            // Determine the new scroll position
            /** @type {?} */
            var newScrollPosition;
            /** @type {?} */
            var stopNow = false;
            if (_pageScrollInstance.endTime <= currentTime) {
                // We're over the time already, so go the targetScrollPosition (aka destination)
                newScrollPosition = _pageScrollInstance.targetScrollPosition;
                stopNow = true;
            }
            else {
                // Calculate the scroll position based on the current time using the easing function
                newScrollPosition = Math.round(_pageScrollInstance.pageScrollOptions.easingLogic(currentTime - _pageScrollInstance.startTime, _pageScrollInstance.startScrollPosition, _pageScrollInstance.distanceToScroll, _pageScrollInstance.executionDuration));
            }
            if (_this.config._logLevel >= 5 && isDevMode()) {
                console.warn('Scroll Position: ' + newScrollPosition);
            }
            // Set the new scrollPosition to all scrollViews elements
            if (!_pageScrollInstance.setScrollPosition(newScrollPosition)) {
                // Setting the new scrollTop/scrollLeft value failed for all ScrollViews
                // early stop the scroll animation to save resources
                stopNow = true;
            }
            // At the end do the internal stop maintenance and fire the pageScrollFinish event
            // (otherwise the event might arrive at "too early")
            if (stopNow) {
                _this.stopInternal(false, _pageScrollInstance);
            }
        }), this.config._interval, pageScrollInstance);
        // Register the instance as running one
        this.runningInstances.push(pageScrollInstance);
    };
    /**
     * @param {?} options
     * @return {?}
     */
    PageScrollService.prototype.scroll = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        this.start(this.create(options));
    };
    /**
     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.
     */
    /**
     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.
     * @param {?=} namespace
     * @return {?}
     */
    PageScrollService.prototype.stopAll = /**
     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.
     * @param {?=} namespace
     * @return {?}
     */
    function (namespace) {
        if (this.runningInstances.length > 0) {
            /** @type {?} */
            var stoppedSome = false;
            for (var i = 0; i < this.runningInstances.length; ++i) {
                /** @type {?} */
                var pageScrollInstance = this.runningInstances[i];
                if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {
                    stoppedSome = true;
                    this.stopInternal(true, pageScrollInstance);
                    // Decrease the counter, as we removed an item from the array we iterate over
                    i--;
                }
            }
            return stoppedSome;
        }
        return false;
    };
    /**
     * @param {?} pageScrollInstance
     * @return {?}
     */
    PageScrollService.prototype.stop = /**
     * @param {?} pageScrollInstance
     * @return {?}
     */
    function (pageScrollInstance) {
        return this.stopInternal(true, pageScrollInstance);
    };
    PageScrollService.instanceCounter = 0;
    PageScrollService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */
    PageScrollService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [NGXPS_CONFIG,] }] }
    ]; };
    /** @nocollapse */ PageScrollService.ngInjectableDef = i0.defineInjectable({ factory: function PageScrollService_Factory() { return new PageScrollService(i0.inject(i1.NGXPS_CONFIG)); }, token: PageScrollService, providedIn: "root" });
    return PageScrollService;
}());
export { PageScrollService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    PageScrollService.instanceCounter;
    /**
     * @type {?}
     * @private
     */
    PageScrollService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    PageScrollService.prototype.runningInstances;
    /**
     * @type {?}
     * @private
     */
    PageScrollService.prototype.onInterrupted;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXBhZ2Utc2Nyb2xsLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtcGFnZS1zY3JvbGwtY29yZS8iLCJzb3VyY2VzIjpbImxpYi9wcm92aWRlcnMvbmd4LXBhZ2Utc2Nyb2xsLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHOUQsT0FBTyxFQUFxQixrQkFBa0IsRUFBcUIsTUFBTSx5QkFBeUIsQ0FBQztBQUNuRyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsWUFBWSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7OztBQUUxRTtJQXlQRSwyQkFBa0MsWUFBOEI7UUFBaEUsaUJBU0M7UUExUE8scUJBQWdCLEdBQXlCLEVBQUUsQ0FBQztRQUU1QyxrQkFBYSxHQUFzQjtZQUN6QyxNQUFNOzs7OztZQUFFLFVBQUMsS0FBWSxFQUFFLGtCQUFzQztnQkFDM0QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixDQUFDLGFBQWEsRUFBRTtvQkFDdkQsb0RBQW9EO29CQUNwRCxPQUFPO2lCQUNSOztvQkFFRyxVQUFVLEdBQUcsSUFBSTtnQkFFckIsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtvQkFDMUIsbUZBQW1GO29CQUNuRixJQUFJLEtBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLG1CQUFlLEtBQUssRUFBQSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7d0JBQ3hFLDBEQUEwRDt3QkFDMUQsVUFBVSxHQUFHLEtBQUssQ0FBQztxQkFDcEI7aUJBQ0Y7cUJBQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBRTtvQkFDckMsMEVBQTBFO29CQUMxRSw4Q0FBOEM7b0JBQzlDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FB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QU0sR0FBRyxDQUFDLEVBQUU7O2dCQUNoQyxXQUFXLEdBQUcsS0FBSztZQUV2QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTs7b0JBQy9DLGtCQUFrQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7Z0JBQ25ELElBQUksQ0FBQyxTQUFTLElBQUksa0JBQWtCLENBQUMsaUJBQWlCLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRTtvQkFDOUUsV0FBVyxHQUFHLElBQUksQ0FBQztvQkFDbkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztvQkFDNUMsNkVBQTZFO29CQUM3RSxDQUFDLEVBQUUsQ0FBQztpQkFDTDthQUNGO1lBRUQsT0FBTyxXQUFXLENBQUM7U0FDcEI7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7Ozs7O0lBRU0sZ0NBQUk7Ozs7SUFBWCxVQUFZLGtCQUFzQztRQUNoRCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDckQsQ0FBQztJQW5QYyxpQ0FBZSxHQUFHLENBQUMsQ0FBQzs7Z0JBSnBDLFVBQVUsU0FBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7Ozs7Z0RBdVBjLE1BQU0sU0FBQyxZQUFZOzs7NEJBL1BsQztDQXlRQyxBQW5RRCxJQW1RQztTQWhRWSxpQkFBaUI7Ozs7OztJQUM1QixrQ0FBbUM7Ozs7O0lBRW5DLG1DQUFpQzs7Ozs7SUFFakMsNkNBQW9EOzs7OztJQUVwRCwwQ0E0QkUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQYWdlU2Nyb2xsQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMvcGFnZS1zY3JvbGwuY29uZmlnJztcbmltcG9ydCB7IEludGVycnVwdFJlcG9ydGVyLCBQYWdlU2Nyb2xsSW5zdGFuY2UsIFBhZ2VTY3JvbGxPcHRpb25zIH0gZnJvbSAnLi4vcGFnZS1zY3JvbGwtaW5zdGFuY2UnO1xuaW1wb3J0IHsgZGVmYXVsdFBhZ2VTY3JvbGxDb25maWcsIE5HWFBTX0NPTkZJRyB9IGZyb20gJy4vY29uZmlnLnByb3ZpZGVyJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VTY3JvbGxTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2VDb3VudGVyID0gMDtcblxuICBwcml2YXRlIGNvbmZpZzogUGFnZVNjcm9sbENvbmZpZztcblxuICBwcml2YXRlIHJ1bm5pbmdJbnN0YW5jZXM6IFBhZ2VTY3JvbGxJbnN0YW5jZVtdID0gW107XG5cbiAgcHJpdmF0ZSBvbkludGVycnVwdGVkOiBJbnRlcnJ1cHRSZXBvcnRlciA9IHtcbiAgICByZXBvcnQ6IChldmVudDogRXZlbnQsIHBhZ2VTY3JvbGxJbnN0YW5jZTogUGFnZVNjcm9sbEluc3RhbmNlKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIXBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9ucy5pbnRlcnJ1cHRpYmxlKSB7XG4gICAgICAgIC8vIE5vbi1pbnRlcnJ1cHRpYmxlIGFueXdheSwgc28gZG8gbm90IHN0b3AgYW55dGhpbmdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2hvdWxkU3RvcCA9IHRydWU7XG5cbiAgICAgIGlmIChldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgIC8vIE9ubHkgc3RvcCBpZiBzcGVjaWZpYyBrZXlzIGhhdmUgYmVlbiBwcmVzc2VkLCBmb3IgYWxsIG90aGVycyBkb24ndCBzdG9wIGFueXRoaW5nXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pbnRlcnJ1cHRLZXlzLmluZGV4T2YoKDxLZXlib2FyZEV2ZW50PmV2ZW50KS5rZXkpID09PSAtMSkge1xuICAgICAgICAgIC8vIFRoZSBwcmVzc2VkIGtleSBpcyBub3QgaW4gdGhlIGxpc3Qgb2YgaW50ZXJydXB0aW5nIGtleXNcbiAgICAgICAgICBzaG91bGRTdG9wID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgLy8gRm9yIG1vdXNlZG93biBldmVudHMgd2Ugb25seSBzdG9wIHRoZSBzY3JvbGwgYW5pbWF0aW9uIG9mIHRoZSBtb3VzZSBoYXNcbiAgICAgICAgLy8gYmVlbiBjbGlja2VkIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lclxuICAgICAgICBpZiAoIXBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxWaWV3cy5zb21lKHNjcm9sbGluZ1ZpZXcgPT4gc2Nyb2xsaW5nVmlldy5jb250YWlucyhldmVudC50YXJnZXQgYXMgTm9kZSkpKSB7XG4gICAgICAgICAgLy8gTW91c2UgY2xpY2tlZCBhbiBlbGVtZW50IHdoaWNoIGlzIG5vdCBpbnNpZGUgYW55IG9mIHRoZSB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lcnNcbiAgICAgICAgICBzaG91bGRTdG9wID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFN0b3ApIHtcbiAgICAgICAgdGhpcy5zdG9wQWxsKHBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9ucy5uYW1lc3BhY2UpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgcHJpdmF0ZSBzdG9wSW50ZXJuYWwoaW50ZXJydXB0ZWQ6IGJvb2xlYW4sIHBhZ2VTY3JvbGxJbnN0YW5jZTogUGFnZVNjcm9sbEluc3RhbmNlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5kZXg6IG51bWJlciA9IHRoaXMucnVubmluZ0luc3RhbmNlcy5pbmRleE9mKHBhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMucnVubmluZ0luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2UuaW50ZXJydXB0TGlzdGVuZXJzQXR0YWNoZWQpIHtcbiAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5kZXRhY2hJbnRlcnJ1cHRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBpZiAocGFnZVNjcm9sbEluc3RhbmNlLnRpbWVyKSB7XG4gICAgICAvLyBDbGVhci9TdG9wIHRoZSB0aW1lclxuICAgICAgY2xlYXJJbnRlcnZhbChwYWdlU2Nyb2xsSW5zdGFuY2UudGltZXIpO1xuICAgICAgLy8gQ2xlYXIgdGhlIHJlZmVyZW5jZSB0byB0aGlzIHRpbWVyXG4gICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZmlyZUV2ZW50KCFpbnRlcnJ1cHRlZCk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGUob3B0aW9uczogUGFnZVNjcm9sbE9wdGlvbnMpOiBQYWdlU2Nyb2xsSW5zdGFuY2Uge1xuICAgIHJldHVybiBuZXcgUGFnZVNjcm9sbEluc3RhbmNlKHsuLi50aGlzLmNvbmZpZywgLi4ub3B0aW9uc30gYXMgUGFnZVNjcm9sbE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgc2Nyb2xsIGFuaW1hdGlvbi4gQWxsIHByb3BlcnRpZXMgb2YgdGhlIGFuaW1hdGlvbiBhcmUgc3RvcmVkIGluIHRoZSBnaXZlbiB7QGxpbmsgUGFnZVNjcm9sbEluc3RhbmNlfSBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIGNvcmUgZnVuY3Rpb25hbGl0eSBvZiB0aGUgd2hvbGUgbGlicmFyeS5cbiAgICovXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjeWNsb21hdGljLWNvbXBsZXhpdHlcbiAgcHVibGljIHN0YXJ0KHBhZ2VTY3JvbGxJbnN0YW5jZTogUGFnZVNjcm9sbEluc3RhbmNlKTogdm9pZCB7XG4gICAgLy8gTWVyZ2UgdGhlIGRlZmF1bHQgb3B0aW9ucyBpbiB0aGUgcGFnZVNjcm9sbEluc3RhbmNlIG9wdGlvbnNcbiAgICBwYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMgPSB7Li4udGhpcy5jb25maWcsIC4uLnBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9uc30gYXMgUGFnZVNjcm9sbE9wdGlvbnM7XG5cbiAgICAvLyBTdG9wIGFsbCBwb3NzaWJseSBydW5uaW5nIHNjcm9sbCBhbmltYXRpb25zIGluIHRoZSBzYW1lIG5hbWVzcGFjZVxuICAgIHRoaXMuc3RvcEFsbChwYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMubmFtZXNwYWNlKTtcblxuICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVmlld3MgPT09IG51bGwgfHwgcGFnZVNjcm9sbEluc3RhbmNlLnBhZ2VTY3JvbGxPcHRpb25zLnNjcm9sbFZpZXdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gTm8gc2Nyb2xsVmlld3Mgc3BlY2lmaWVkLCB0aHVzIHdlIGNhbid0IGFuaW1hdGUgYW55dGhpbmdcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5fbG9nTGV2ZWwgPj0gMiB8fCAodGhpcy5jb25maWcuX2xvZ0xldmVsID49IDEgJiYgaXNEZXZNb2RlKCkpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gc2Nyb2xsVmlld3Mgc3BlY2lmaWVkLCB0aHVzIG5neC1wYWdlLXNjcm9sbCBkb2VzIG5vdCBrbm93IHdoaWNoIERPTSBlbGVtZW50cyB0byBzY3JvbGwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBzdGFydFNjcm9sbFBvc2l0aW9uRm91bmQgPSBmYWxzZTtcbiAgICAvLyBSZXNldCBzdGFydCBzY3JvbGwgcG9zaXRpb24gdG8gMC4gSWYgYW55IG9mIHRoZSBzY3JvbGxWaWV3cyBoYXMgYSBkaWZmZXJlbnQgb25lLCBpdCB3aWxsIGJlIGV4dHJhY3RlZCBuZXh0XG4gICAgcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb24gPSAwO1xuXG4gICAgLy8gR2V0IHRoZSBzdGFydCBzY3JvbGwgcG9zaXRpb24gZnJvbSB0aGUgc2Nyb2xsVmlld3MgKGUuZy4gaWYgdGhlIHVzZXIgYWxyZWFkeSBzY3JvbGxlZCBkb3duIHRoZSBjb250ZW50KVxuICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxWaWV3cy5mb3JFYWNoKChzY3JvbGxpbmdWaWV3OiBhbnkpID0+IHtcbiAgICAgIGlmIChzY3JvbGxpbmdWaWV3ID09PSB1bmRlZmluZWQgfHwgc2Nyb2xsaW5nVmlldyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBHZXQgdGhlIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0IHZhbHVlIG9mIHRoZSBmaXJzdCBzY3JvbGxpbmdWaWV3IHRoYXQgcmV0dXJucyBhIHZhbHVlIGZvciBpdHMgXCJzY3JvbGxUb3BcIlxuICAgICAgLy8gb3IgXCJzY3JvbGxMZWZ0XCIgcHJvcGVydHkgdGhhdCBpcyBub3QgdW5kZWZpbmVkIGFuZCB1bmVxdWFsIHRvIDBcblxuICAgICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBwYWdlU2Nyb2xsSW5zdGFuY2UuZ2V0U2Nyb2xsUHJvcGVydHlWYWx1ZShzY3JvbGxpbmdWaWV3KTtcbiAgICAgIGlmICghc3RhcnRTY3JvbGxQb3NpdGlvbkZvdW5kICYmIHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgIC8vIFdlIGZvdW5kIGEgc2Nyb2xsaW5nVmlldyB0aGF0IGRvZXMgbm90IGhhdmUgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQgMFxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlLCBhcyB0aGlzIHdpbGwgYmUgb3VyIHN0YXJ0U2Nyb2xsUG9zaXRpb25cbiAgICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgc3RhcnRTY3JvbGxQb3NpdGlvbkZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHBhZ2VTY3JvbGxPZmZzZXQgPSBwYWdlU2Nyb2xsSW5zdGFuY2UuZ2V0Q3VycmVudE9mZnNldCgpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0YXJnZXQgcG9zaXRpb24gdGhhdCB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBzaG91bGQgZ28gdG9cblxuICAgIGNvbnN0IHNjcm9sbFRhcmdldFBvc2l0aW9uID0gcGFnZVNjcm9sbEluc3RhbmNlLmV4dHJhY3RTY3JvbGxUYXJnZXRQb3NpdGlvbigpO1xuICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbiA9IE1hdGgucm91bmQoXG4gICAgICAocGFnZVNjcm9sbEluc3RhbmNlLnBhZ2VTY3JvbGxPcHRpb25zLnZlcnRpY2FsU2Nyb2xsaW5nID8gc2Nyb2xsVGFyZ2V0UG9zaXRpb24udG9wIDogc2Nyb2xsVGFyZ2V0UG9zaXRpb24ubGVmdCkgLSBwYWdlU2Nyb2xsT2Zmc2V0KTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugd2UgbmVlZCB0byBnbyBpbiB0b3RhbFxuICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5kaXN0YW5jZVRvU2Nyb2xsID0gcGFnZVNjcm9sbEluc3RhbmNlLnRhcmdldFNjcm9sbFBvc2l0aW9uIC0gcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb247XG5cbiAgICBpZiAoaXNOYU4ocGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwpKSB7XG4gICAgICAvLyBXZSB3ZXJlbid0IGFibGUgdG8gZmluZCB0aGUgdGFyZ2V0IHBvc2l0aW9uLCBtYXliZSB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdD9cblxuICAgICAgaWYgKHRoaXMuY29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8ICh0aGlzLmNvbmZpZy5fbG9nTGV2ZWwgPj0gMSAmJiBpc0Rldk1vZGUoKSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbGluZyBub3QgcG9zc2libGUsIGFzIHdlIGNhblxcJ3QgZmluZCB0aGUgc3BlY2lmaWVkIHRhcmdldCcpO1xuICAgICAgfVxuICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmZpcmVFdmVudChmYWxzZSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSdyZSBhdCB0aGUgZmluYWwgZGVzdGluYXRpb24gYWxyZWFkeVxuICAgIC8vIE9SIHdlIG5lZWQgdG8gc2Nyb2xsIGRvd24gYnV0IGFyZSBhbHJlYWR5IGF0IHRoZSBlbmRcbiAgICAvLyBPUiB3ZSBuZWVkIHRvIHNjcm9sbCB1cCBidXQgYXJlIGF0IHRoZSB0b3AgYWxyZWFkeVxuICAgIGNvbnN0IGFsbFJlYWR5QXREZXN0aW5hdGlvbiA9IE1hdGguYWJzKHBhZ2VTY3JvbGxJbnN0YW5jZS5kaXN0YW5jZVRvU2Nyb2xsKSA8IHBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9ucy5fbWluU2Nyb2xsRGlzdGFuY2U7XG5cbiAgICAvLyBDaGVjayBob3cgbG9uZyB3ZSBuZWVkIHRvIHNjcm9sbCBpZiBhIHNwZWVkIG9wdGlvbiBpcyBnaXZlblxuICAgIC8vIERlZmF1bHQgZXhlY3V0aW9uRHVyYXRpb24gaXMgdGhlIHNwZWNpZmllZCBkdXJhdGlvblxuICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5leGVjdXRpb25EdXJhdGlvbiA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9ucy5kdXJhdGlvbjtcbiAgICAvLyBNYXliZSB3ZSBuZWVkIHRvIHBheSBhdHRlbnRpb24gdG8gdGhlIHNwZWVkIG9wdGlvbj9cbiAgICBpZiAoKHBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9ucy5zcGVlZCAhPT0gdW5kZWZpbmVkICYmIHBhZ2VTY3JvbGxJbnN0YW5jZS5wYWdlU2Nyb2xsT3B0aW9ucy5zcGVlZCAhPT0gbnVsbCkgJiZcbiAgICAgIChwYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fCBwYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMuZHVyYXRpb24gPT09IG51bGwpKSB7XG4gICAgICAvLyBTcGVlZCBvcHRpb24gaXMgc2V0IGFuZCBubyBkdXJhdGlvbiA9PiBjYWxjdWxhdGUgZHVyYXRpb24gYmFzZWQgb24gc3BlZWQgYW5kIHNjcm9sbCBkaXN0YW5jZVxuICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmV4ZWN1dGlvbkR1cmF0aW9uID1cbiAgICAgICAgTWF0aC5hYnMocGFnZVNjcm9sbEluc3RhbmNlLmRpc3RhbmNlVG9TY3JvbGwpIC8gcGFnZVNjcm9sbEluc3RhbmNlLnBhZ2VTY3JvbGxPcHRpb25zLnNwZWVkICogMTAwMDtcbiAgICB9XG5cbiAgICAvLyBXZSBzaG91bGQgZ28gdGhlcmUgZGlyZWN0bHksIGFzIG91ciBcImFuaW1hdGlvblwiIHdvdWxkIGhhdmUgb25lIGJpZyBzdGVwXG4gICAgLy8gb25seSBhbnl3YXkgYW5kIHRoaXMgd2F5IHdlIHNhdmUgdGhlIGludGVydmFsIHN0dWZmXG4gICAgY29uc3QgdG9vU2hvcnRJbnRlcnZhbCA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5leGVjdXRpb25EdXJhdGlvbiA8PSBwYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMuX2ludGVydmFsO1xuXG4gICAgaWYgKGFsbFJlYWR5QXREZXN0aW5hdGlvbiB8fCB0b29TaG9ydEludGVydmFsKSB7XG4gICAgICBpZiAodGhpcy5jb25maWcuX2xvZ0xldmVsID49IDIgfHwgKHRoaXMuY29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGlzRGV2TW9kZSgpKSkge1xuICAgICAgICBpZiAoYWxsUmVhZHlBdERlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbGluZyBub3QgcG9zc2libGUsIGFzIHdlIGNhblxcJ3QgZ2V0IGFueSBjbG9zZXIgdG8gdGhlIGRlc3RpbmF0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbCBkdXJhdGlvbiBzaG9ydGVyIHRoYXQgaW50ZXJ2YWwgbGVuZ3RoLCBqdW1waW5nIHRvIHRhcmdldCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYWdlU2Nyb2xsSW5zdGFuY2Uuc2V0U2Nyb2xsUG9zaXRpb24ocGFnZVNjcm9sbEluc3RhbmNlLnRhcmdldFNjcm9sbFBvc2l0aW9uKTtcbiAgICAgIHBhZ2VTY3JvbGxJbnN0YW5jZS5maXJlRXZlbnQodHJ1ZSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgaW50ZXJydXB0IGxpc3RlbmVycyBpZiB3ZSB3YW50IGFuIGludGVycnVwdGlibGUgc2Nyb2xsIGFuaW1hdGlvblxuICAgIGlmIChwYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMuaW50ZXJydXB0aWJsZSkge1xuICAgICAgcGFnZVNjcm9sbEluc3RhbmNlLmF0dGFjaEludGVycnVwdExpc3RlbmVycyh0aGlzLm9uSW50ZXJydXB0ZWQpO1xuICAgIH1cblxuICAgIC8vIExldCdzIGdldCBzdGFydGVkLCBnZXQgdGhlIHN0YXJ0IHRpbWUuLi5cbiAgICBwYWdlU2Nyb2xsSW5zdGFuY2Uuc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgLy8gLi4gYW5kIGNhbGN1bGF0ZSB0aGUgZW5kIHRpbWUgKHdoZW4gd2UgbmVlZCB0byBmaW5pc2ggYXQgbGFzdClcbiAgICBwYWdlU2Nyb2xsSW5zdGFuY2UuZW5kVGltZSA9IHBhZ2VTY3JvbGxJbnN0YW5jZS5zdGFydFRpbWUgKyBwYWdlU2Nyb2xsSW5zdGFuY2UuZXhlY3V0aW9uRHVyYXRpb247XG5cbiAgICBwYWdlU2Nyb2xsSW5zdGFuY2UudGltZXIgPSBzZXRJbnRlcnZhbCgoX3BhZ2VTY3JvbGxJbnN0YW5jZTogUGFnZVNjcm9sbEluc3RhbmNlKSA9PiB7XG4gICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lOiBudW1iZXIgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBuZXcgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICBsZXQgbmV3U2Nyb2xsUG9zaXRpb246IG51bWJlcjtcbiAgICAgIGxldCBzdG9wTm93ID0gZmFsc2U7XG4gICAgICBpZiAoX3BhZ2VTY3JvbGxJbnN0YW5jZS5lbmRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIFdlJ3JlIG92ZXIgdGhlIHRpbWUgYWxyZWFkeSwgc28gZ28gdGhlIHRhcmdldFNjcm9sbFBvc2l0aW9uIChha2EgZGVzdGluYXRpb24pXG4gICAgICAgIG5ld1Njcm9sbFBvc2l0aW9uID0gX3BhZ2VTY3JvbGxJbnN0YW5jZS50YXJnZXRTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgc3RvcE5vdyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCB0aW1lIHVzaW5nIHRoZSBlYXNpbmcgZnVuY3Rpb25cbiAgICAgICAgbmV3U2Nyb2xsUG9zaXRpb24gPSBNYXRoLnJvdW5kKF9wYWdlU2Nyb2xsSW5zdGFuY2UucGFnZVNjcm9sbE9wdGlvbnMuZWFzaW5nTG9naWMoXG4gICAgICAgICAgY3VycmVudFRpbWUgLSBfcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0VGltZSxcbiAgICAgICAgICBfcGFnZVNjcm9sbEluc3RhbmNlLnN0YXJ0U2Nyb2xsUG9zaXRpb24sXG4gICAgICAgICAgX3BhZ2VTY3JvbGxJbnN0YW5jZS5kaXN0YW5jZVRvU2Nyb2xsLFxuICAgICAgICAgIF9wYWdlU2Nyb2xsSW5zdGFuY2UuZXhlY3V0aW9uRHVyYXRpb24pKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5fbG9nTGV2ZWwgPj0gNSAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbCBQb3NpdGlvbjogJyArIG5ld1Njcm9sbFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIFNldCB0aGUgbmV3IHNjcm9sbFBvc2l0aW9uIHRvIGFsbCBzY3JvbGxWaWV3cyBlbGVtZW50c1xuICAgICAgaWYgKCFfcGFnZVNjcm9sbEluc3RhbmNlLnNldFNjcm9sbFBvc2l0aW9uKG5ld1Njcm9sbFBvc2l0aW9uKSkge1xuICAgICAgICAvLyBTZXR0aW5nIHRoZSBuZXcgc2Nyb2xsVG9wL3Njcm9sbExlZnQgdmFsdWUgZmFpbGVkIGZvciBhbGwgU2Nyb2xsVmlld3NcbiAgICAgICAgLy8gZWFybHkgc3RvcCB0aGUgc2Nyb2xsIGFuaW1hdGlvbiB0byBzYXZlIHJlc291cmNlc1xuICAgICAgICBzdG9wTm93ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQXQgdGhlIGVuZCBkbyB0aGUgaW50ZXJuYWwgc3RvcCBtYWludGVuYW5jZSBhbmQgZmlyZSB0aGUgcGFnZVNjcm9sbEZpbmlzaCBldmVudFxuICAgICAgLy8gKG90aGVyd2lzZSB0aGUgZXZlbnQgbWlnaHQgYXJyaXZlIGF0IFwidG9vIGVhcmx5XCIpXG4gICAgICBpZiAoc3RvcE5vdykge1xuICAgICAgICB0aGlzLnN0b3BJbnRlcm5hbChmYWxzZSwgX3BhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzLmNvbmZpZy5faW50ZXJ2YWwsIHBhZ2VTY3JvbGxJbnN0YW5jZSk7XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgaW5zdGFuY2UgYXMgcnVubmluZyBvbmVcbiAgICB0aGlzLnJ1bm5pbmdJbnN0YW5jZXMucHVzaChwYWdlU2Nyb2xsSW5zdGFuY2UpO1xuICB9XG5cbiAgcHVibGljIHNjcm9sbChvcHRpb25zOiBQYWdlU2Nyb2xsT3B0aW9ucyk6IHZvaWQge1xuICAgIHRoaXMuc3RhcnQodGhpcy5jcmVhdGUob3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgYWxsIHJ1bm5pbmcgc2Nyb2xsIGFuaW1hdGlvbnMuIE9wdGlvbmFsbHkgbGltaXQgdG8gc3RvcCBvbmx5IHRoZSBvbmVzIG9mIHNwZWNpZmljIG5hbWVzcGFjZS5cbiAgICovXG4gIHB1YmxpYyBzdG9wQWxsKG5hbWVzcGFjZT86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdJbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHN0b3BwZWRTb21lID0gZmFsc2U7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nSW5zdGFuY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBhZ2VTY3JvbGxJbnN0YW5jZSA9IHRoaXMucnVubmluZ0luc3RhbmNlc1tpXTtcbiAgICAgICAgaWYgKCFuYW1lc3BhY2UgfHwgcGFnZVNjcm9sbEluc3RhbmNlLnBhZ2VTY3JvbGxPcHRpb25zLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgc3RvcHBlZFNvbWUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RvcEludGVybmFsKHRydWUsIHBhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGNvdW50ZXIsIGFzIHdlIHJlbW92ZWQgYW4gaXRlbSBmcm9tIHRoZSBhcnJheSB3ZSBpdGVyYXRlIG92ZXJcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3BwZWRTb21lO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBzdG9wKHBhZ2VTY3JvbGxJbnN0YW5jZTogUGFnZVNjcm9sbEluc3RhbmNlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcEludGVybmFsKHRydWUsIHBhZ2VTY3JvbGxJbnN0YW5jZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KE5HWFBTX0NPTkZJRykgY3VzdG9tQ29uZmlnOiBQYWdlU2Nyb2xsQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB7Li4uZGVmYXVsdFBhZ2VTY3JvbGxDb25maWcsIC4uLmN1c3RvbUNvbmZpZ307XG5cbiAgICBpZiAoUGFnZVNjcm9sbFNlcnZpY2UuaW5zdGFuY2VDb3VudGVyID4gMCAmJlxuICAgICAgKHRoaXMuY29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8ICh0aGlzLmNvbmZpZy5fbG9nTGV2ZWwgPj0gMSAmJiBpc0Rldk1vZGUoKSkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0FuIGluc3RhbmNlIG9mIFBhZ2VTY3JvbGxTZXJ2aWNlIGFscmVhZHkgZXhpc3RzLCB1c3VhbGx5ICcgK1xuICAgICAgICAnaW5jbHVkaW5nIG9uZSBwcm92aWRlciBzaG91bGQgYmUgZW5vdWdoLCBzbyBkb3VibGUgY2hlY2suJyk7XG4gICAgfVxuICAgIFBhZ2VTY3JvbGxTZXJ2aWNlLmluc3RhbmNlQ291bnRlcisrO1xuICB9XG59XG4iXX0=